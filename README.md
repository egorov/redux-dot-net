# Redux-мини для .NET

Это простая реализация "контейнера состояния" по мотивам [Redux для JavaScript](https://redux.js.org/).

## Что это?
Концептуально, собственно контейнер состояния представляет собой обычный `IDictonary<string, object>`, а управление этим контейнером осуществляется методами отдельного объекта `Store` (хранилище). Изящество решения в минимальном количестве этих методов. Собственно их буквально три:

    public interface Store
    {
        void Dispatch(Message message);
        IDictionary<string, object> GetState();
        Action Subscribe(Action<Message> handler);
    }

Метод `Dispatch` позволяет отправлять сообщения `хранилищу` контейнера. Метод `GetState` позволяет получить копию текущего контейнера состояния со всем содержимым. И метод `Subscribe` позволяет подписаться на событие отправки сообщения. При этом следует иметь в виду что уведомления о таких событиях `хранилище` отправляет только при обработке тех типов сообщений, о которых оно осведомлено. 

### Как настроить хранилище?
О каких же типах событий осведомлено `хранилище`? О тех, для которых разработчик реализовал `редукторы` и при настройке `хранилища`, передал эти редукторы в конструктор `хранилища`.

Минимальный процесс настройки `хранилища`, с использованием простейших штатных `редукторов` может выглядеть к примеру вот так:

    List<Reducer> reducers = new List<Reducer>();
    reducers.Add(new ReducerImpl("User"));
    reducers.Add(new ReducerImpl("Group"));
    reducers.Add(new ReducerImpl("EmailConfirmation"));
    reducers.Add(new ExceptionReducerImpl());

    Store store = new StoreImpl(reducers);

### Как отправить сообщение?

Теперь можно отправлять `хранилищу` сообщения:

    User payload = new User() { 
            Login = "jack", 
            Password = "P@ssw0rd" 
        };

    Message message = new Message("User", payload);

    store.Dispatch(message);

### Что там в контейнере?

И получать копию содержимого контейнера:

    IDictionary<string, object> state = store.GetState();

    User user = state["User"] as User;

Реализация штатного редуктора `ReducerImpl` умеет просто обновлять содержимое ячейки контейнера с указанным при конструировании редуктора типом сообщения:

    string type = "User";
    Reducer reducer = new ReducerImpl(type);

После этого, если вы отправите `хранилищу` сообщение с типом `"User"`, редуктор обновит значение, хранимое в ячейке контейнера с ключом `"User"`, что было продемонстрировано в предыдущих фрагментах кода выше.

### Как узнать об изменениях содержимого контейнера?

Как упоминалось ранее, `хранилище` умеет сообщать всем желающим об изменениях в контейнере. Чтобы начать получать уведомления об изменении необходимо подписаться на события отправки сообщений. В идеале, метод, подписывающийся на событие, должен иметь доступ к контейнеру состояний, посредством методов хранилища. Поэтому обработчик лучше описывать в отдельном классе, которому при конструировании передается экземпляр `хранилища`. Например так:

    public class CustomHandler
    {
        private Store store;
        
        public CustomHandler(Store store)
        {
            this.store = store;
        }

        public void Handle(Message message)
        {
            IDictionary<string, object> state = this.store.GetState();

            /// Здесь кодируем необходимое поведение
        }
    }

Теперь можно подписать наш обработчик на события `хранилища` и код метода `Handle` будет вызываться всякий раз, когда кто-нибудь будет отправлять сообщение.

    CustomHandler handler = new CustomHandler(store);

    Action unsubscribe = store.Subscribe(handler.Handle);

Вызов метода `Subscribe` возвращает ссылку на метод, который позволяет отписаться от получения уведомлений об поступлении сообщения в `хранилище`.